/****************************************************************************
**
** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
** All rights reserved.
** Contact: http://www.qt-project.org/
**
** This file is part of the QtCore module of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:LGPL$
** GNU Lesser General Public License Usage
** This file may be used under the terms of the GNU Lesser General Public
** License version 2.1 as published by the Free Software Foundation and
** appearing in the file LICENSE.LGPL included in the packaging of this
** file. Please review the following information to ensure the GNU Lesser
** General Public License version 2.1 requirements will be met:
** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
** In addition, as a special exception, Nokia gives you certain additional
** rights. These rights are described in the Nokia Qt LGPL Exception
** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU General
** Public License version 3.0 as published by the Free Software Foundation
** and appearing in the file LICENSE.GPL included in the packaging of this
** file. Please review the following information to ensure the GNU General
** Public License version 3.0 requirements will be met:
** http://www.gnu.org/copyleft/gpl.html.
**
** Other Usage
** Alternatively, this file may be used in accordance with the terms and
** conditions contained in a signed written agreement between you and Nokia.
**
**
**
**
**
** $QT_END_LICENSE$
**
****************************************************************************/

//
//  W A R N I N G
//  -------------
//
// This file is not part of the Qt API.  It exists for the convenience
// of other Qt classes.  This header file may change from version to
// version without notice, or even be removed.
//
// We mean it.
//

// This file was generated by qlalr - DO NOT EDIT!
#ifndef QLALR_PARSER_CPP
#define QLALR_PARSER_CPP

#if defined(ERROR)
#  undef ERROR
#endif

class parser_table
{
public:
  enum VariousConstants {
    EOF_SYMBOL = 0,
    T_START = 1,
    T_PREC = 2,
    T_TOKEN = 3,
    T_LEFT = 4,
    T_RIGHT = 5,
    T_NONASSOC = 6,
    T_TOKEN_PREFIX = 7,
    T_MERGED_OUTPUT = 8,
    T_PARSER = 9,
    T_DECL_FILE = 10,
    T_IMPL_FILE = 11,
    T_EXPECT = 12,
    T_EXPECT_RR = 13,
    T_IDENTIFIER = 14,
    T_STRING_LITERAL = 15,
    T_SEMICOLON = 16,
    T_COLON = 17,
    T_COLON_COLON_EQUAL = 18,
    T_BAR = 19,
    T_ERROR = 20,

    ACCEPT_STATE = 26,
    RULE_COUNT = 41,
    STATE_COUNT = 58,
    TERMINAL_COUNT = 21,
    NON_TERMINAL_COUNT = 21,

    GOTO_INDEX_OFFSET = 58,
    GOTO_INFO_OFFSET = 60,
    GOTO_CHECK_OFFSET = 60
  };

  static const char  *const    spell [];
  static const short             lhs [];
  static const short             rhs [];
  static const short    goto_default [];
  static const short  action_default [];
  static const short    action_index [];
  static const short     action_info [];
  static const short    action_check [];

  static inline int nt_action (int state, int nt)
  {
    const int yyn = action_index [GOTO_INDEX_OFFSET + state] + nt;
    if (yyn < 0 || action_check [GOTO_CHECK_OFFSET + yyn] != nt)
      return goto_default [nt];

    return action_info [GOTO_INFO_OFFSET + yyn];
  }

  static inline int t_action (int state, int token)
  {
    const int yyn = action_index [state] + token;

    if (yyn < 0 || action_check [yyn] != token)
      return - action_default [state];

    return action_info [yyn];
  }
};


const char *const parser_table::spell [] = {
  "end of file", 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0};

const short parser_table::lhs [] = {
  21, 22, 23, 24, 24, 25, 25, 26, 26, 27,
  27, 27, 27, 27, 27, 27, 28, 28, 28, 28,
  29, 30, 30, 31, 31, 32, 33, 33, 34, 35,
  36, 36, 37, 38, 38, 38, 38, 39, 40, 40,
  41};

const short parser_table::rhs [] = {
  2, 1, 3, 1, 2, 1, 2, 1, 1, 2,
  2, 2, 2, 2, 2, 2, 1, 1, 1, 1,
  2, 1, 2, 1, 2, 2, 1, 3, 1, 4,
  1, 1, 1, 0, 1, 2, 1, 2, 1, 2,
  1};

const short parser_table::action_default [] = {
  0, 20, 0, 4, 18, 0, 9, 2, 0, 0,
  8, 0, 0, 0, 0, 17, 0, 0, 19, 12,
  10, 22, 21, 24, 13, 14, 1, 11, 16, 15,
  0, 5, 0, 23, 25, 0, 3, 6, 33, 26,
  32, 34, 31, 7, 37, 0, 0, 39, 27, 35,
  41, 40, 36, 38, 30, 34, 29, 28};

const short parser_table::goto_default [] = {
  0, 12, 7, 17, 36, 3, 10, 8, 6, 22,
  21, 30, 46, 55, 37, 41, 35, 48, 49, 44,
  47};

const short parser_table::action_index [] = {
  39, -21, -12, -21, -21, -11, -21, -21, -13, -14,
  -21, -2, 21, -1, 0, -21, -3, 28, -21, -21,
  -21, -21, -5, -10, -21, -21, -21, -21, -21, -21,
  -4, -21, -6, -21, -21, 5, -8, -21, -21, -21,
  -21, 13, -21, -21, 16, -7, 1, -21, -21, -21,
  -21, -21, -21, -21, -21, 2, -21, -21,

  -21, -21, -21, -21, -21, -21, -21, -21, -21, -21,
  -21, -21, -21, -21, -21, -21, -21, -4, -21, -21,
  -21, -21, 1, -21, -21, -21, -21, -21, -21, -21,
  -21, -21, -21, -21, -21, -21, -10, -21, -21, -21,
  -21, -21, -21, -21, -15, -21, -21, -21, -21, -21,
  -21, -21, -21, -21, -21, -17, -21, -21};

const short parser_table::action_info [] = {
  24, 23, 19, 20, 45, 34, 38, 53, 39, 23,
  38, 29, 25, 27, 28, 45, 50, 54, 45, 0,
  56, 26, 42, 40, 0, 0, 0, 50, 0, 32,
  50, 15, 4, 18, 1, 5, 13, 2, 9, 11,
  16, 14, 15, 4, 18, 1, 5, 13, 2, 9,
  11, 16, 14, 0, 0, 0, 0, 0, 0, 0,

  57, 31, 0, 52, 43, 51, 0, 0, 0, 0,
  0, 33, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0};

const short parser_table::action_check [] = {
  14, 14, 14, 14, 2, 15, 14, 14, 14, 14,
  14, 14, 14, 14, 14, 2, 14, 16, 2, -1,
  19, 0, 17, 18, -1, -1, -1, 14, -1, 1,
  14, 3, 4, 5, 6, 7, 8, 9, 10, 11,
  12, 13, 3, 4, 5, 6, 7, 8, 9, 10,
  11, 12, 13, -1, -1, -1, -1, -1, -1, -1,

  17, 5, -1, 18, 14, 20, -1, -1, -1, -1,
  -1, 10, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1};


#include "qlalr.h"
#include "cppgenerator.h"
#include <QtCore/QFile>
#include <QtCore/QTextStream>

struct Parser: parser_table {
    Options *flags;
    int yytos;
    int yystateStack[128];
    QString yysymStack[128];
    QString yylval;
    Grammar G;
    Automaton A;

    int terminalKind;
    Token::Assoc assoc;
    int prec;
    QSet<QString> stringSet;

    int yylineno;
    QChar yychar;
    QString source;
    QString yytext;
    const QChar *yycode;

    inline static bool isIdentChar(const QChar &ch)
    {
        if (ch.isLetterOrNumber())
            return true;
        else {
            switch (ch.unicode()) {
            case '-':
            case '_':
            case '.':
                return true;
            default:
                return false;
            }
        }

        return false;
    }

    inline void yyinp()
    {
        yychar = *yycode++;

        if (yychar == QLatin1Char('\n'))
            ++yylineno;
    }

    int yylex();
    void yyreduce(int ruleno);

    QString &sym(int n) {
        return yysymStack[yytos + n - 1];
    }

    const QString &string(int n) {
        return yysymStack[yytos + n - 1];
    }

    QString lineInfo()
    {
        if (flags->no_lines)
            return QString();

        return QLatin1String ("\n#line ") + QString::number(yylineno) + " \"" + flags->filename+ "\"\n";
    }

    QString expand(const QString &var, bool *expanded)
    {
        *expanded = true;
        if (var == QLatin1String("rule_number") && ! G.rules.isEmpty())
            return QString::number(G.currentRule()->index);
        else if (var == QLatin1String("table"))
            return flags->table_name;
        else if (var == QLatin1String("header"))
            return flags->table_name.toLower() + QLatin1String("_p.h");
        else if (var == QLatin1String("rule") && ! G.rules.isEmpty())
            return G.currentRule()->lhs;
        expanded = false;
        return var;
    }

    Parser(Options *flags)
        : flags(flags)
        , yylineno(1)
        , yycode(0)
    {
        QFile file(flags->filename);
        if (file.open(QFile::ReadOnly)) {
            source = QTextStream(&file).readAll();
            yycode = source.unicode();
            yychar = QLatin1Char('\n');
        }
    }

    bool yyparse()
    {
        if (! yycode) {
            fprintf(stderr, "qlalr: no input file\n");
            return false;
        }
        int yyaction = 0;
        int yytoken = -1;

        terminalKind = 0;
        assoc = Token::Nonassoc;
        prec = -1;

        yytos = -1;

        do {
            yystateStack[++yytos] = yyaction;
            if (yytoken == -1 && action_index[yyaction] != -TERMINAL_COUNT)
                yytoken = yylex();
            yyaction = t_action(yyaction, yytoken);
            if (yyaction > 0) {
                if (yyaction == ACCEPT_STATE) {
                    --yytos;
                    return true;
                }
                yysymStack[yytos] = yylval;
                yytoken = -1;
            } else if (yyaction < 0) {
                int ruleno = -yyaction - 1;
                yytos -= rhs[ruleno];
                yyreduce(ruleno);
                yyaction = nt_action(yystateStack[yytos], lhs[ruleno] - TERMINAL_COUNT);
            }
        } while (yyaction);
        fprintf(stderr, "syntax error at line %d\n", yylineno);
        return false;
    }
};

#include "cppgenerator.h"
#include <QtCore/QDebug>

void Parser::yyreduce(int ruleno)
{
    switch (ruleno) {

case 1: {
    // check the grammar
    QSet<QString> undefinedSymbols;
    foreach (Rule *r, G.rules) {
        foreach (const QString &symbol, r->rhs) {
            if (G.indexOfName(symbol) == -1)
                undefinedSymbols.insert(symbol);
        }
    }

    foreach (const QString &u, undefinedSymbols) {
        fprintf(stderr, "error: undefined symbol %s\n", qPrintable(u));
    }

    if (! undefinedSymbols.isEmpty())
        break;

    // compute the qlalr items
    QVector<DottedItem> kernel;
    foreach (Rule *r, G.alternatives.value(G.acceptSymbol()))
        kernel.push_back(DottedItem(r, 0));
    qSort(kernel);
    A.start = A.getState(kernel);
    Q_ASSERT(A.start->index != -1);
    QVector<State *> wl;
    wl.push_back(A.start);
    QSet<State *> visited;
    while (! wl.empty()) {
        State *state = wl.front();
        wl.pop_front();
        if (! visited.contains(state)) {
            visited.insert(state);
            foreach (State *n, A.next(state))
                wl.push_back(n);
        }
    }

    A.gen(&G);

#ifdef QLALR_DEBUG
    foreach (const QString &nt, G.nullables)
        fprintf(stderr, "%s is nullable\n", qPrintable(nt));
#endif

    CppGenerator gen(flags, &G, &A, false);
    gen.setDebugInfo(! flags->no_debug);
    gen.setCopyright(flags->qt);

    gen();
    if (flags->verbose) {
        G.dump(stdout);
        A.dump(&G, stdout);
    }
} break;

case 9: {
    flags->token_prefix = string(2);
} break;

case 10: {
    flags->merged_output = string(2);
} break;

case 11: {
    flags->table_name = string(2);
} break;

case 12: {
    flags->decl_file_name = string(2);
} break;

case 13: {
    flags->impl_file_name = string(2);
} break;

case 14: {
    flags->expected_shift_reduce = string(2).toInt();
} break;

case 15: {
    flags->expected_reduce_reduce = string(2).toInt();
} break;

case 16: {
    terminalKind = T_TOKEN;
    assoc = Token::Nonassoc;
} break;

case 17: {
    terminalKind = T_LEFT;
    assoc = Token::Left;
    ++prec;
} break;

case 18: {
    terminalKind = T_RIGHT;
    assoc = Token::Right;
    ++prec;
} break;

case 19: {
    terminalKind = T_NONASSOC;
    assoc = Token::Nonassoc;
    ++prec;
} break;

case 23: {
    G.enterToken(string(1), QString(), assoc, terminalKind == T_TOKEN ? -1 : prec);
} break;

case 24: {
    G.enterToken(string(1), string(2), assoc, terminalKind == T_TOKEN ? -1 : prec);
} break;

case 25: {
    G.setStartSymbol(string(2));
} break;

case 28: {
    G.finishRule();
    QString lhs = G.currentRule()->lhs;
    G.startRule(lhs);
} break;

case 29: {
    G.finishRule();
} break;

case 32: {
    G.startRule(string(1));
} break;

case 37: {
    const int precTokenIndex = G.indexOfToken(string(2));
    if (precTokenIndex == -1)
        fprintf(stderr, "warning: undefined token %s\n", qPrintable(string(2)));
    else
        G.currentRule()->precToken = precTokenIndex;
} break;

case 40: {
    G.enterSymbol(string(1));
} break;

    } // switch
}


int Parser::yylex()
{
again:
    while (yychar.isSpace())
        yyinp();

    if (yychar.isNull())
        return EOF_SYMBOL;

    const QChar ch = yychar;
    yyinp();

    if (ch == QLatin1Char('%') && yychar == QLatin1Char('%')) {
        yyinp();  // skip %%
        goto again;
    } else if (ch == QLatin1Char('%') && isIdentChar(yychar)) {
        yytext.clear();
        while (isIdentChar(yychar)) {
            yytext += yychar;
            yyinp();
        }
        if (yytext == QLatin1String("token_prefix")) return T_TOKEN_PREFIX;
        else if (yytext == QLatin1String("merged_output")) return T_MERGED_OUTPUT;
        else if (yytext == QLatin1String("token")) return T_TOKEN;
        else if (yytext == QLatin1String("start")) return T_START;
        else if (yytext == QLatin1String("parser")) return T_PARSER;
        else if (yytext == QLatin1String("decl")) return T_DECL_FILE;
        else if (yytext == QLatin1String("impl")) return T_IMPL_FILE;
        else if (yytext == QLatin1String("expect")) return T_EXPECT;
        else if (yytext == QLatin1String("expect-rr")) return T_EXPECT_RR;
        else if (yytext == QLatin1String("left")) return T_LEFT;
        else if (yytext == QLatin1String("right")) return T_RIGHT;
        else if (yytext == QLatin1String("nonassoc")) return T_NONASSOC;
        else if (yytext == QLatin1String("prec")) return T_PREC;
        fprintf(stderr, "unrecognized directive %s\n", qPrintable(yytext));
        return T_ERROR;
    } else if ((ch == QLatin1Char('-') && yychar == QLatin1Char('-')) ||
               (ch == QLatin1Char('/') && yychar == QLatin1Char('/'))) {
        // skip single-line comments
        for (; ! yychar.isNull(); yyinp()) {
            if (yychar == QLatin1Char('\n'))
                break;
        }
        goto again;
    } else if (ch == QLatin1Char('/') && yychar == QLatin1Char('*')) {
        yyinp(); // skip *
        int startLine = yylineno;
        while (! yychar.isNull()) {
            if (yychar == QLatin1Char('*')) {
                yyinp();
                if (yychar == QLatin1Char('/')) {
                    yyinp();
                    goto again;
                }
            } else {
                yyinp();
            }
        }
        fprintf(stderr, "%s:%d: error: unterminated multiline comment\n",
                qPrintable(flags->filename), startLine);
    } else if (ch == QLatin1Char('/') && (yychar == QLatin1Char(':') ||
                                          yychar == QLatin1Char('.'))) {
        const QChar terminator = yychar;
        yyinp(); // skip ':' or '.'
        yytext.clear();
        int startLine = yylineno;
        while (! yychar.isNull()) {
            if (yychar == QLatin1Char('$')) {
                yyinp(); // skip '$'
                if (isIdentChar(yychar)) {
                    QString word;
                    for (; isIdentChar(yychar); yyinp())
                        word += yychar;

                    bool isKeyword = false;
                    const QString expanded = expand(word, &isKeyword);

                    if (isKeyword)
                        yytext += expanded;
                    else {
                        yytext += QLatin1Char('$');
                        yytext += word;
                    }
                } else {
                    yytext += QLatin1Char('$');
                }
            }
            if (yychar == terminator) {
                yyinp();
                if (yychar == QLatin1Char('/')) {
                    yyinp();
                    if (yychar.isNull() || yychar.isSpace()) {
                        if (terminator == QLatin1Char(':')) {
                            flags->decl_text += yytext;
                            goto again;
                        } else if (terminator == QLatin1Char('.')) {
                            flags->impl_text += yytext;
                            goto again;
                        }
                        yytext += terminator;
                        yytext += yychar;
                    } else {
                        yytext += yychar;
                    }
                } else {
                    yytext += terminator;
                }
            } else {
                yytext += yychar;
                yyinp();
            }
        }
        fprintf(stderr, "%s:%d: error: unterminated code block\n",
                qPrintable(flags->filename), startLine);
    } else {
        switch (ch.unicode()) {
        case '"':
            yytext.clear();
            while (! yychar.isNull()) {
                if (yychar == QLatin1Char('\n')) {
                    break;
                } else if (yychar == QLatin1Char('"')) {
                    yyinp();
                    yylval = yytext;
                    return T_STRING_LITERAL;
                } else if (yychar == QLatin1Char('\\')) {
                    yytext += yychar;
                    yyinp();
                    if (! yychar.isNull()) {
                        yytext += yychar;
                        yyinp();
                    }
                } else {
                    yytext += yychar;
                    yyinp();
                }
            }
            fprintf(stderr, "%s:%d: error: unterminated string literal\n",
                    qPrintable(flags->filename), yylineno);
            return T_ERROR;

        case ':':
            if (yychar == QLatin1Char(':')) {
                yyinp();
                if (yychar == QLatin1Char('=')) {
                    yyinp();
                    return T_COLON_COLON_EQUAL;
                }
                return T_ERROR; // recognized ::
            }
            return T_COLON;

        case ';':
            return T_SEMICOLON;

        case '|':
            return T_BAR;

        default:
            if (isIdentChar(ch)) {
                yytext.clear();
                yytext += ch;
                while (isIdentChar(yychar)) {
                    yytext += yychar;
                    yyinp();
                }
                yylval = yytext;
                return T_IDENTIFIER;
            }

        } // switch
    }

    return T_ERROR;
}

#include <QtCore/QCoreApplication>
#include <QtCore/QStringList>
#include <cstdlib>

static void help_me ()
{
    fprintf(stderr, "Usage: qlalr [options] [input file name]\n\n"
            "  --help, -h\t\tdisplay this help and exit\n"
            "  --verbose, -v\t\tverbose output\n"
            "  --no-debug\t\tno debug information\n"
            "  --no-lines\t\tno #line directives\n"
            "  --qt\t\t\tadd the Qt copyright header and Qt-specific types and macros\n");
    exit(0);
}

int main(int argc, char *argv[])
{
    QCoreApplication app(argc, argv);

    QStringList args = app.arguments();
    args.removeFirst();

    Options options;
    foreach (const QString &arg, args) {
        if (arg == QLatin1String("--verbose") || arg == QLatin1String("-v"))
            options.verbose = true;
        else if (arg == QLatin1String("--qt"))
            options.qt = true;
        else if (arg == QLatin1String("--no-lines"))
            options.no_lines = true;
        else if (arg == QLatin1String("--no-debug"))
            options.no_debug = true;
        else if (arg == QLatin1String("--help") || arg == QLatin1String("-h"))
            help_me();
        else if (options.filename.isEmpty())
            options.filename = arg;
        else
            help_me();
    }

    if (options.filename.isEmpty())
        help_me();

    Parser parser(&options);
    if (! parser.yyparse())
        return EXIT_FAILURE;
    return 0;
}

#endif // QLALR_PARSER_CPP

